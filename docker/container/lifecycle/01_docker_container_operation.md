# 1. 도커 컨테이너 작업

## 1.1 컨테이너 생성

### 1.1.1 기본 생성
```bash
docker create [옵션] 이미지[:태그]
```

### 1.1.2 주요 옵션
- `--name`: 컨테이너 이름 지정
- `-p`, `--publish`: 포트 매핑
- `-v`, `--volume`: 볼륨 마운트
- `-e`, `--env`: 환경변수 설정

## 1.2 컨테이너 실행

### 1.2.1 새 컨테이너 실행
```bash
docker run [옵션] 이미지[:태그] [명령어]
```

### 1.2.2 실행 옵션
- `-d`, `--detach`: 백그라운드 실행
- `-i`, `--interactive`: 표준 입력 유지
- `-t`, `--tty`: TTY 할당
- `--rm`: 컨테이너 종료 시 자동 삭제

## 1.3 컨테이너 상태 관리

### 1.3.1 시작과 정지
```bash
docker start 컨테이너_이름
docker stop 컨테이너_이름
```

### 1.3.2 일시 중지와 재개
```bash
docker pause 컨테이너_이름
docker unpause 컨테이너_이름
```

## 1.4 컨테이너 정보 확인

### 1.4.1 목록 확인
```bash
docker ps [옵션]
```

#### 1.4.1.1 주요 옵션
- `-a`, `--all`: 모든 컨테이너 표시
- `-q`, `--quiet`: ID만 표시
- `-s`, `--size`: 크기 표시

### 1.4.2 상세 정보
```bash
docker inspect 컨테이너_이름
```

## 1.5 컨테이너 리소스 관리

### 1.5.1 리소스 제한
```bash
docker run --memory="512m" --cpus="1.0" 이미지
```

### 1.5.2 리소스 모니터링
```bash
docker stats [컨테이너_이름]
```

## 2. 컨테이너 생명주기

### 2.1. 기본 단계
컨테이너의 생명주기는 일반적으로 생성, 실행, 종료, 폐기의 단계를 거칩니다. 새로운 기능을 개발하거나 설정을 변경한 후에는 기존 컨테이너를 폐기하고 새로운 컨테이너를 생성하는 과정을 반복하게 됩니다. 이러한 과정을 통해 애플리케이션 환경을 일관성 있게 유지하고 관리할 수 있습니다.

## 3. 데이터 관리

### 3.1. 데이터 보존
컨테이너는 삭제될 때 내부 데이터가 함께 삭제되는 휘발성 스토리지를 사용합니다. 따라서 중요한 데이터를 영구적으로 보존하기 위해서는 물리적인 디스크(HDD/SSD)와 같은 컨테이너 외부 저장소에 데이터를 저장해야 합니다. 이를 통해 컨테이너의 생명주기와 관계없이 데이터를 안전하게 관리할 수 있습니다.

### 3.2. 데이터 관리 전략
운영체제나 소프트웨어와 같은 애플리케이션 환경은 컨테이너를 통해 관리하고, 실제 데이터는 컨테이너 외부에 위치한 저장소에 영구적으로 보관하는 것이 효율적인 전략입니다. 설정 파일 역시 외부 저장소에 보관하여 컨테이너를 재배포하거나 확장할 때 일관성을 유지할 수 있습니다. 또한, 외부 저장소를 사용하면 여러 컨테이너 간에 데이터를 공유하는 것도 가능합니다.

## 4. 활용 사례

### 4.1. 개발환경 표준화
도커를 사용하면 팀원 모두에게 동일한 개발 환경을 제공하여 환경 설정으로 인한 문제를 줄일 수 있습니다. 각 프로젝트별로 독립된 컨테이너를 운영함으로써 라이브러리 버전 충돌 등의 의존성 문제를 해결하고, 개발 환경과 운영 환경의 일관성을 높여 예측 가능하고 안정적인 개발 프로세스를 구축할 수 있습니다.

### 4.2. 테스트 환경
도커는 새로운 운영체제나 라이브러리 버전을 테스트하는 데 매우 유용합니다. 실제 운영 환경에 적용하기 전에 도커 컨테이너를 이용하여 개발 환경을 검증함으로써 잠재적인 문제를 사전에 파악하고 해결할 수 있습니다. 도커 엔진이 설치된 환경이라면 어디서든 동일한 테스트 환경을 구성할 수 있다는 장점이 있습니다.

### 4.3. 서버 확장
도커를 사용하면 하나의 물리 서버에서 여러 개의 동일한 서비스를 독립적으로 실행할 수 있어 서버 자원을 효율적으로 활용할 수 있습니다. 이는 서버 관리의 용이성을 높이고, 추가적인 물리 서버 구매 비용을 절감하는 효과를 가져옵니다. 또한, 필요에 따라 서버를 빠르게 배포하고 확장할 수 있어 서비스의 가용성과 확장성을 향상시킬 수 있습니다.